data IController with
    event void ok_fired;
    var float ax, ay;
end

data Keys with
    var int fire;
    var int up, down, left, right;
end

code/await Controller (var Keys keys) => (var& IController ctrl) => void
do
    var IController ctrl_ = val IController(_,0,0);
    ctrl = &ctrl_;

    par do
        every key in SDL_KEYDOWN do
            if key:keysym.sym == keys.up then
                ctrl_.ay = -(WIN_H as float)/5000;
            else/if key:keysym.sym == keys.down then
                ctrl_.ay =  (WIN_H as float)/5000;
            else/if key:keysym.sym == keys.left then
                ctrl_.ax = -(WIN_W as float)/5000;
            else/if key:keysym.sym == keys.right then
                ctrl_.ax =  (WIN_W as float)/5000;
            else/if key:keysym.sym == keys.fire then
                emit ctrl_.ok_fired;
            end
        end
    with
        every key in SDL_KEYUP do
            if key:keysym.sym == keys.up
            or key:keysym.sym == keys.down then
                ctrl_.ay = 0;
            else/if key:keysym.sym == keys.left
                 or key:keysym.sym == keys.right then
                ctrl_.ax = 0;
            end
        end
    end
end

data IMovable with
    var& SDL_Rect rect;
    var& float vx;
    var& float vy;
    var& float ax;
    var& float ay;
end

code/await Move (var& IMovable obj) => void
do
    var float sx = obj.rect.x;
    var float sy = obj.rect.y;

    loop do
        var int dt = await SDL_DT;

        obj.vx = obj.vx + obj.ax*dt;
        sx = sx + obj.vx*dt/1000;
        obj.rect.x = (sx as int);
        if obj.rect.x < 0
        or obj.rect.x > WIN_W then
            break;
        end

        obj.vy = obj.vy + obj.ay*dt;
        sy = sy + obj.vy*dt/1000;
        obj.rect.y = (sy as int);
        if obj.rect.y < 0
        or obj.rect.y > WIN_H then
            break;
        end
    end
end

code/await Fire (
        var SDL_Point pos,
        var float     vx,
        var float     vy,
        var int       width,
    ) => void
do
    var int w = WIN_W/50 + WIN_W*width/100;
    var int h = WIN_H/250;
    var SDL_Rect rect = val SDL_Rect(pos.x,pos.y, w,h);

    var float a = 0;
    var IMovable obj = val IMovable(&rect, &vx,&vy, &a,&a);

    watching Move(&obj) do
        every SDL_REDRAW do
            _boxRGBA(outer.ren, rect.x,rect.y, rect.x+rect.w,rect.y+rect.h,
                                0xFF,0xFF,0x88,0xFF);
        end
    end
end

code/await Ship (
        var& SDL_Texture tex,
        var  SDL_Point   pos,
        var  Orientation ori,
        var& IController ctrl,
    ) => void
do
    var int dim = tex.width;
    var SDL_Rect clip = val SDL_Rect(0,0, dim,dim);
    var SDL_Rect rect = val SDL_Rect(pos.x,pos.y, dim,dim);

    var float vx = 0;
    var float vy = 0;
    var IMovable obj = val IMovable(&rect, &vx,&vy, &ctrl.ax,&ctrl.ay);

    watching Move(&obj) do
        par do
            loop do
                await 5s;
                await Fire (
                        SDL_Point(rect.x,rect.y),
                        WIN_W/3 * (ori as int),
                        vy,
                        1
                      );
            end
        with
            every SDL_REDRAW do

                // set sprite frame depending on the controller acceleration
                if ctrl.ay > 0 then
                    clip.y = dim*3;
                else/if ctrl.ay < 0 then
                    clip.y = dim*2;
                else/if ctrl.ax*(ori as int) < 0 then
                    clip.y = 0;
                else
                    clip.y = dim*1;
                end

                // redraw sprite frame
                var SDL_Rect r = val SDL_Rect(rect.x-dim/2, rect.y-dim/2, dim,dim);
                _SDL_RenderCopy(outer.ren, tex.ptr, (&&clip as _SDL_Rect&&),
                                                    (&&r as _SDL_Rect&&));
            end
        end
    end

    // explode 40w/s
    _Mix_PlayChannel(-1, outer.snd_explosion, 0);
    watching 100ms do
        par do
            var float d = dim;
            var float v = 40 * dim;
            every dt in SDL_DT do
                d = d + v*dt/1000;
                rect.w = d as int;
                rect.h = d as int;
            end
        with
            every SDL_REDRAW do
                _filledCircleRGBA(outer.ren, rect.x,rect.y,rect.w,
                                             0xFF,0x00,0x00,0xFF);
            end
        end
    end
end
