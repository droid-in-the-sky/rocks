data IController with
    event void ok_fired;
    var float ax, ay;
end

data Keys with
    var int fire;
    var int up, down, left, right;
end

code/await Controller (var Keys keys) => (var& IController ctrl) => void
do
    var IController ctrl_ = val IController(_,0,0);
    ctrl = &ctrl_;

    par do
        var _SDL_KeyboardEvent&& key;
        every key in SDL_KEYDOWN do
            if key:keysym.sym == keys.up then
                ctrl_.ay = -(WIN_H as float)/5000;
            else/if key:keysym.sym == keys.down then
                ctrl_.ay =  (WIN_H as float)/5000;
            else/if key:keysym.sym == keys.left then
                ctrl_.ax = -(WIN_W as float)/5000;
            else/if key:keysym.sym == keys.right then
                ctrl_.ax =  (WIN_W as float)/5000;
            else/if key:keysym.sym == keys.fire then
                emit ctrl_.ok_fired;
            end
        end
    with
        var _SDL_KeyboardEvent&& key;
        every key in SDL_KEYUP do
            if key:keysym.sym == keys.up
            or key:keysym.sym == keys.down then
                ctrl_.ay = 0;
            else/if key:keysym.sym == keys.left
                 or key:keysym.sym == keys.right then
                ctrl_.ax = 0;
            end
        end
    end
end

code/await Fire (
        var SDL_Point pos,
        var float     vx,
        var float     vy,
        var int       width,
    ) => void
do
    var int w = WIN_W/50 + WIN_W*width/100;
    var int h = WIN_H/250;
    var SDL_Rect rect = val SDL_Rect(pos.x,pos.y, w,h);

    var Movable mov = val Movable(Axis(rect.x, vx, 0),
                                  Axis(rect.y, vy, 0));

    watching Move(&rect, &mov) do
        every SDL_REDRAW do
            _boxRGBA(outer.ren, rect.x,rect.y, rect.x+rect.w,rect.y+rect.h,
                                0xFF,0xFF,0x88,0xFF);
        end
    end
end

data Limits with
    var SDL_Point pt1;
    var SDL_Point pt2;
end

code/await Ship (
        var& SDL_Texture tex,
        var  SDL_Point   pos,
        var  Orientation ori,
        var  Limits      lim,
        var& IController ctrl,
    ) => (
        var& SDL_Rect rect,
    ) => void
do
    #define DIM tex.width

    var SDL_Rect rect_ = val SDL_Rect(pos.x,pos.y, DIM,DIM);
    rect = &rect_;

    var Movable mov = val Movable(Axis(rect_.x, 0, 0),
                                  Axis(rect_.y, 0, 0));
    watching Move(&rect_, &mov) do
        par do
            loop do
                await 5s;
                await Fire (
                        SDL_Point(rect_.x,rect_.y),
                        WIN_W/3 * (ori as int),
                        mov.y.v,
                        1
                      );
            end
        with
            var int dt;
            every dt in SDL_DT do
                mov.x.a = ctrl.ax;
                mov.y.a = ctrl.ay;

                if mov.x.v >  WIN_W/10 then mov.x.v =  WIN_W/10; end
                if mov.x.v < -WIN_W/10 then mov.x.v = -WIN_W/10; end
                if mov.y.v >  WIN_H/10 then mov.y.v =  WIN_H/10; end
                if mov.y.v < -WIN_H/10 then mov.y.v = -WIN_H/10; end

                // Positions are limited to the screen limits:
                if mov.x.s < lim.pt1.x then
                    mov.x.s = lim.pt1.x;
                    mov.x.v = 0;
                else/if mov.x.s > lim.pt2.x then
                    mov.x.s = lim.pt2.x;
                    mov.x.v = 0;
                end
                if mov.y.s < lim.pt1.y then
                    mov.y.s = lim.pt1.y;
                    mov.y.v = 0;
                else/if mov.y.s > lim.pt2.y then
                    mov.y.s = lim.pt2.y;
                    mov.y.v = 0;
                end
            end
        with
            var SDL_Rect clip = val SDL_Rect(0,0, DIM,DIM);
            every SDL_REDRAW do
                // set sprite frame depending on the controller acceleration
                if mov.y.a > 0 then
                    clip.y = DIM*3;
                else/if mov.y.a < 0 then
                    clip.y = DIM*2;
                else/if mov.y.a*(ori as int) < 0 then
                    clip.y = 0;
                else
                    clip.y = DIM*1;
                end

                // redraw sprite frame
                var SDL_Rect r = val SDL_Rect(rect_.x-DIM/2, rect_.y-DIM/2,
                                              DIM,DIM);
                _SDL_RenderCopy(outer.ren, tex.ptr, (&&clip as _SDL_Rect&&),
                                                    (&&r as _SDL_Rect&&));
            end
        end
    end

    // explode 40w/s
    _Mix_PlayChannel(-1, outer.snd_explosion, 0);
    watching 100ms do
        par do
            var float d = DIM;
            var float v = 40 * DIM;
            var int dt;
            every dt in SDL_DT do
                d = d + v*dt/1000;
                rect_.w = d as int;
                rect_.h = d as int;
            end
        with
            every SDL_REDRAW do
                _filledCircleRGBA(outer.ren, rect_.x,rect_.y,rect_.w,
                                             0xFF,0x00,0x00,0xFF);
            end
        end
    end

    #undef DIM
end
