data IController with
    event void ok_fired;
    var float ax, ay;
end

data Keys with
    var int fire;
    var int up, down, left, right;
end

code/await Controller (var Keys keys) => (var& IController ctrl) => void
do
    var IController ctrl_ = val IController(_,0,0);
    ctrl = &ctrl_;

    par do
        every key in SDL_KEYDOWN do
            if key:keysym.sym == keys.up then
                ctrl_.ay = -(WIN_H as float)/5000;
            else/if key:keysym.sym == keys.down then
                ctrl_.ay =  (WIN_H as float)/5000;
            else/if key:keysym.sym == keys.left then
                ctrl_.ax = -(WIN_W as float)/5000;
            else/if key:keysym.sym == keys.right then
                ctrl_.ax =  (WIN_W as float)/5000;
            else/if key:keysym.sym == keys.fire then
                emit ctrl_.ok_fired;
            end
        end
    with
        every key in SDL_KEYUP do
            if key:keysym.sym == keys.up
            or key:keysym.sym == keys.down then
                ctrl_.ay = 0;
            else/if key:keysym.sym == keys.left
                 or key:keysym.sym == keys.right then
                ctrl_.ax = 0;
            end
        end
    end
end

data Axis with
    var float s;
    var float v;
    var float a;
end

data Movable with
    var Axis x;
    var Axis y;
end

code/await Move (var& SDL_Rect rect, var& Movable obj) => void
do
    loop do
        var int dt = await SDL_DT;

        obj.x.v = obj.x.v + obj.x.a*dt;
        obj.x.s = obj.x.s + obj.x.v*dt/1000;
        rect.x = obj.x.s as int;

        obj.y.v = obj.y.v + obj.y.a*dt;
        obj.y.s = obj.y.s + obj.y.v*dt/1000;
        rect.y = obj.y.s as int;

        if obj.x.s<0 or obj.x.s>WIN_W then
            break;
        end
        if obj.y.s<0 or obj.y.s>WIN_H then
            break;
        end
    end
end

code/await Fire (
        var SDL_Point pos,
        var float     vx,
        var float     vy,
        var int       width,
    ) => void
do
    var int w = WIN_W/50 + WIN_W*width/100;
    var int h = WIN_H/250;
    var SDL_Rect rect = val SDL_Rect(pos.x,pos.y, w,h);

    var Movable obj = val Movable(Axis(rect.x, vx, 0),
                                  Axis(rect.y, vy, 0));

    watching Move(&rect, &obj) do
        every SDL_REDRAW do
            _boxRGBA(outer.ren, rect.x,rect.y, rect.x+rect.w,rect.y+rect.h,
                                0xFF,0xFF,0x88,0xFF);
        end
    end
end

data Orientation;
data Orientation.Right is  1;
data Orientation.Left  is -1;

data Limits with
    var SDL_Point pt1;
    var SDL_Point pt2;
end

code/await Ship (
        var& SDL_Texture tex,
        var  SDL_Point   pos,
        var  Orientation ori,
        var  Limits      lim,
        var& IController ctrl,
    ) => void
do
    var SDL_Rect clip = val SDL_Rect(0,0,         DIM_OUT,DIM_OUT);
    var SDL_Rect rect = val SDL_Rect(pos.x,pos.y, DIM_OUT,DIM_OUT);

    var Movable obj = val Movable(Axis(rect.x, 0, 0),
                                  Axis(rect.y, 0, 0));
    watching Move(&rect, &obj) do
        par do
            loop do
                await 5s;
                await Fire (
                        SDL_Point(rect.x,rect.y),
                        WIN_W/3 * (ori as int),
                        obj.y.v,
                        1
                      );
            end
        with
            every dt in SDL_DT do
                obj.x.a = ctrl.ax;
                obj.y.a = ctrl.ay;

                if obj.x.v >  WIN_W/10 then obj.x.v =  WIN_W/10; end
                if obj.x.v < -WIN_W/10 then obj.x.v = -WIN_W/10; end
                if obj.y.v >  WIN_H/10 then obj.y.v =  WIN_H/10; end
                if obj.y.v < -WIN_H/10 then obj.y.v = -WIN_H/10; end

                // Positions are limited to the screen limits:
                if obj.x.s < lim.pt1.x then
                    obj.x.s = lim.pt1.x;
                    obj.x.v = 0;
                else/if obj.x.s > lim.pt2.x then
                    obj.x.s = lim.pt2.x;
                    obj.x.v = 0;
                end
                if obj.y.s < lim.pt1.y then
                    obj.y.s = lim.pt1.y;
                    obj.y.v = 0;
                else/if obj.y.s > lim.pt2.y then
                    obj.y.s = lim.pt2.y;
                    obj.y.v = 0;
                end
            end
        with
            every SDL_REDRAW do

                // set sprite frame depending on the controller acceleration
                if obj.y.a > 0 then
                    clip.y = DIM_OUT*3;
                else/if obj.y.a < 0 then
                    clip.y = DIM_OUT*2;
                else/if obj.y.a*(ori as int) < 0 then
                    clip.y = 0;
                else
                    clip.y = DIM_OUT*1;
                end

                // redraw sprite frame
                var SDL_Rect r = val SDL_Rect(rect.x-DIM_OUT/2, rect.y-DIM_OUT/2,
                                              DIM_OUT,DIM_OUT);
                _SDL_RenderCopy(outer.ren, tex.ptr, (&&clip as _SDL_Rect&&),
                                                    (&&r as _SDL_Rect&&));
            end
        end
    end

    // explode 40w/s
    _Mix_PlayChannel(-1, outer.snd_explosion, 0);
    watching 100ms do
        par do
            var float d = DIM_OUT;
            var float v = 40 * DIM_OUT;
            every dt in SDL_DT do
                d = d + v*dt/1000;
                rect.w = d as int;
                rect.h = d as int;
            end
        with
            every SDL_REDRAW do
                _filledCircleRGBA(outer.ren, rect.x,rect.y,rect.w,
                                             0xFF,0x00,0x00,0xFF);
            end
        end
    end
end
