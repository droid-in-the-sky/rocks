code/await Fire (
        var SDL_Point pos,
        var float     vx,
        var float     vy,
        var int       width,
    ) => (
        var& Collideable col,
    ) => void
do
    var int w = WIN_W/50 + WIN_W*width/100;
    var int h = WIN_H/250;
    var SDL_Rect rect = val SDL_Rect(pos.x,pos.y, w,h);

    event void ok_collided;
    var Collideable col_ = val Collideable(&rect, &ok_collided);
    col = &col_;

    var Movable mov = val Movable(Axis(rect.x, vx, 0),
                                  Axis(rect.y, vy, 0));

    watching Move(&rect, &mov)
           , ok_collided
    do
        every SDL_REDRAW do
            _boxRGBA(outer.ren, rect.x,rect.y, rect.x+rect.w,rect.y+rect.h,
                                0xFF,0xFF,0x88,0xFF);
        end
    end
end

data Limits with
    var SDL_Point pt1;
    var SDL_Point pt2;
end

code/await Ship (
        var&    SDL_Texture tex,
        var     SDL_Point   pos,
        var     Orientation ori,
        var     Limits      lim,
        var&    IController ctrl,
        pool&[] Fire        fires,
    ) => (
        var& Collideable col,
    ) => void
do
    #define DIM tex.width

    var SDL_Rect rect = val SDL_Rect(pos.x,pos.y, DIM,DIM);

    event void ok_collided;
    var Collideable col_ = val Collideable(&rect, &ok_collided);
    col = &col_;

    var Movable mov = val Movable(Axis(rect.x, 0, 0),
                                  Axis(rect.y, 0, 0));
    spawn Move(&rect, &mov);

    watching ok_collided do
        par do
            every ctrl.ok_fired do
                spawn Fire (
                        SDL_Point(rect.x,rect.y),
                        WIN_W/3 * (ori as int),
                        mov.y.v,
                        1,
                      ) in fires;
            end
        with
            var int dt;
            every dt in SDL_DT do
                mov.x.a = ctrl.ax;
                mov.y.a = ctrl.ay;

                if mov.x.v >  WIN_W/10 then mov.x.v =  WIN_W/10; end
                if mov.x.v < -WIN_W/10 then mov.x.v = -WIN_W/10; end
                if mov.y.v >  WIN_H/10 then mov.y.v =  WIN_H/10; end
                if mov.y.v < -WIN_H/10 then mov.y.v = -WIN_H/10; end

                // Positions are limited to the screen limits:
                if mov.x.s < lim.pt1.x then
                    mov.x.s = lim.pt1.x;
                    mov.x.v = 0;
                else/if mov.x.s > lim.pt2.x then
                    mov.x.s = lim.pt2.x;
                    mov.x.v = 0;
                end
                if mov.y.s < lim.pt1.y then
                    mov.y.s = lim.pt1.y;
                    mov.y.v = 0;
                else/if mov.y.s > lim.pt2.y then
                    mov.y.s = lim.pt2.y;
                    mov.y.v = 0;
                end
            end
        with
            var SDL_Rect clip = val SDL_Rect(0,0, DIM,DIM);
            every SDL_REDRAW do
                // set sprite frame depending on the controller acceleration
                if mov.y.a > 0 then
                    clip.y = DIM*3;
                else/if mov.y.a < 0 then
                    clip.y = DIM*2;
                else/if mov.y.a*(ori as int) < 0 then
                    clip.y = 0;
                else
                    clip.y = DIM*1;
                end

                // redraw sprite frame
                var SDL_Rect r = val SDL_Rect(rect.x-DIM/2, rect.y-DIM/2,
                                              DIM,DIM);
                _SDL_RenderCopy(outer.ren, tex.ptr, (&&clip as _SDL_Rect&&),
                                                    (&&r as _SDL_Rect&&));
            end
        end
    end

    // explode 40w/s
    _Mix_PlayChannel(-1, outer.snd_explosion, 0);
    watching 100ms do
        par do
            var float d = DIM;
            var float v = 40 * DIM;
            var int dt;
            every dt in SDL_DT do
                d = d + v*dt/1000;
                rect.w = d as int;
                rect.h = d as int;
            end
        with
            every SDL_REDRAW do
                _filledCircleRGBA(outer.ren, rect.x,rect.y,rect.w,
                                             0xFF,0x00,0x00,0xFF);
            end
        end
    end

    #undef DIM
end
